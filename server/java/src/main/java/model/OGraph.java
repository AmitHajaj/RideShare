package model;

import controller.GraphUtils;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

public class OGraph {
    // edges id generated by calculacateEdgeId() method below:
    private Set<OEdge> edges;
    // access through node id:
    private Map<Long, ONode> nodes;

    private Map<Long, ONode> junctionNodes = new HashMap<>();

    private HashMap<Long, Integer> nodesQuantity = new HashMap<>();//TODO check needed

    /**
     * Singleton specific properties:
     */

    private static OGraph INSTANCE = new OGraph();

    private OGraph() {
        this.edges = new HashSet<>();
        this.nodes = new HashMap<>();
    }

    public static OGraph getInstance() {
        return INSTANCE;
    }


    /**
     * Getters:
     */
    public Map<Long, ONode> getNodes() { return nodes; }

    public int getNodeQuantity(long l) { return nodesQuantity.get(l); }

    public Set<OEdge> getEdges() { return edges; }

    public ONode getNode(long key){
        return this.nodes.get(key);
    }

    public Map<Long, ONode> getJunctionNodes() {
        return junctionNodes;
    }

    /**
     * Setters:
     */

    public OEdge addEdge(OEdge e){
        this.edges.add(e);
        return e;
    }

    public void setNodeQuantity(Long l, int i) { this.nodesQuantity.put(l, 0); }

    public ONode addNode(ONode node, long id){
        nodes.put(id, node);
        return node;
    }

    public ONode addNode(ONode node){
        nodes.put(node.getOsm_Id(), node);
        return node;
    }

    public ONode removeNode(long id){
        ONode removed = this.nodes.remove(id);

        Iterator<OEdge> itr = removed.getEdges().iterator();
        while(itr.hasNext()){
            removeEdge(itr.next());
        }
        return removed;
    }

    public void removeNodes(List<Long> nodeKeys){

        for(int i = 0; i < nodeKeys.size(); i++){
            Long id = nodeKeys.get(i);

            ONode removed = this.nodes.remove(id);
            ArrayList<OEdge> oEdgesCopy = new ArrayList<>(removed.getEdges());
            for (OEdge e:oEdgesCopy) {
                removeEdge(e);
            }
        }
    }

    public boolean removeEdge(OEdge e){
        e.getEndNode().removeEdgeTo(e.getStartNode());
        e.getStartNode().removeEdgeTo(e.getEndNode());
        return this.edges.remove(e);
    }

    public void removeEdge(OEdge e, Iterator<OEdge> itr){
        e.getEndNode().removeEdgeTo(e.getStartNode());
        e.getStartNode().removeEdgeTo(e.getEndNode());
        itr.remove();
    }

    /**
     * Function to find the closest node to a given point
     * @param node- the node to which the closest node is to be found
     * @return the closest node to the given node
     */
    public ONode findClosestNode(ONode node){
        //Get the coordinates of the node
        Double latitude = node.getLatitude();
        Double longitude = node.getLongitude();

        //Assign default variables
        AtomicReference<Double> minDistance = new AtomicReference<>(Double.MAX_VALUE);
        AtomicReference<ONode> closestNode = new AtomicReference<>(node);

        //Loop through all the nodes that are not from Rider type, and find the closest one
        this.nodes.values().stream().filter(n -> n.getUser() != ONode.userType.Rider)
                .forEach(n -> {
                    double dist = GraphUtils.distance(latitude, longitude, n.getLatitude(), n.getLongitude());
                    if(dist < minDistance.get()){
                        minDistance.set(dist);
                        closestNode.set(n);
                    }
                });

        return closestNode.get();
    }

    @Override
    public String toString() {
        return "OGraph{" +
                "edges=" + this.edges.size() +
                ", nodes=" + this.nodes.size() +
                '}';
    }
}