package model;

import controller.utils.GraphAlgo;
import controller.osmProcessing.OMapWay;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

public class OGraph {
    // edges id generated by calculacateEdgeId() method below:
    private Set<OEdge> edges;
    // access through node id:
    private Map<Long, ONode> nodes;

    private Map<Long, ONode> junctionNodes = new HashMap<>();

    private HashMap<Long, Integer> nodesQuantity = new HashMap<>();//TODO check needed

    /**
     * Singleton specific properties:
     */

    private static OGraph INSTANCE = new OGraph();

    private OGraph() {
        this.edges = new HashSet<>();
        this.nodes = new HashMap<>();
    }

    public static OGraph getInstance() {
        return INSTANCE;
    }


    /**
     * Getters:
     */
    public Map<Long, ONode> getNodes() { return nodes; }

    public int getNodeQuantity(long l) { return nodesQuantity.get(l); }

    public Set<OEdge> getEdges() { return edges; }

    public ONode getNode(long key){
        return this.nodes.get(key);
    }

    public Map<Long, ONode> getJunctionNodes() {
        return junctionNodes;
    }

    /**
     * Setters:
     */

    public void setEdges(Set<OEdge> edges) {
        this.edges = edges;
    }

    /** add edge from osm file */
    public OEdge addEdge(ONode src, ONode dst, OMapWay way){
        boolean srcToDst = src.isAdjacent(dst);
        boolean dstToSrc = dst.isAdjacent(src);

        OEdge edge = null;

        if(srcToDst && dstToSrc){
            return src.getEdgeTo(dst);
        }else if(dstToSrc){
            edge = dst.getEdgeTo(src);
        }else if(!srcToDst){
            edge = new OEdge(way, src, dst);
        }

        src.addEdge(edge);
        this.edges.add(edge);

        return edge;
    }

    /** add edge from DB */
    public OEdge addEdge(String id, Long startNodeId, Long endNodeID, Double weight, String highwayType) {
        OEdge edge = new OEdge(id, startNodeId, endNodeID, weight, 0.0, "", highwayType);
        addEdge(edge);

        return edge;
    }

    private void addEdge(OEdge e){
        if(!e.getStartNode().isAdjacent(e.getEndNode())) {
            e.getStartNode().addEdge(e);
            e.getEndNode().addEdge(e);
//            e.getLength();
            edges.add(e);
        }else{
            e.setDirected(true);
        }
    }

    public void setNodeQuantity(Long l, int i) { this.nodesQuantity.put(l, 0); }

    //TODO make private
    public ONode addNode(ONode node, long id){
        nodes.put(id, node);
        return node;
    }

    public ONode addNode(ONode node){
        nodes.put(node.getOsm_Id(), node);
        return node;
    }

    public ONode addNode(String id, Long osmID, Double latitude, Double longitude, ONode.userType user){
        ONode node = new ONode(id, osmID, latitude, longitude, ONode.userType.None);
        return addNode(node);
    }

    public ONode removeNode(long id){
        ONode node = this.nodes.remove(id);

        node.getEdges().forEach(edge ->{
            ONode otherEnd = edge.getOtherEnd(node.getId());
            otherEnd.removeEdgeTo(node);
            edges.remove(edge);
        });

        return nodes.remove(id);
    }

    public void removeNodes(List<ONode> nodes){

        List<OEdge> edgesToRemove = new ArrayList<>();
        int a = 0;
        for(ONode node:nodes) {
            this.nodes.remove(node.getOsm_Id());
            if(node.getOsm_Id() == 560149987l || node.getOsm_Id() == 560149995l){
                int stop = 0;
            }
            for (OEdge edge : node.getEdges()) {
//                System.out.println(a++);
//                ONode otherEnd = edge.getOtherEnd(node.getId());
//                otherEnd.removeEdge(edge);//removeEd(node);
                edgesToRemove.add(edge);
            }
        }


        edges.removeAll(edgesToRemove);
//        this.nodes.removeAll(nodes);
    }

//    public void removeNodes(List<Long> nodeKeys){
//
//        for(int i = 0; i < nodeKeys.size(); i++){
//            Long id = nodeKeys.get(i);
//
//            ONode removed = this.nodes.remove(id);
//            ArrayList<OEdge> oEdgesCopy = new ArrayList<>(removed.getEdges());
//            for (OEdge e:oEdgesCopy) {
//                removeEdge(e);
//            }
//        }
//    }

    public boolean removeEdge(OEdge e){
        e.getEndNode().removeEdgeTo(e.getStartNode());
        e.getStartNode().removeEdgeTo(e.getEndNode());
        return this.edges.remove(e);
    }

    public void removeEdge(OEdge e, Iterator<OEdge> itr){
        e.getEndNode().removeEdgeTo(e.getStartNode());
        e.getStartNode().removeEdgeTo(e.getEndNode());
        itr.remove();
    }

    /**
     * Function to find the closest node to a given point
     * @param node- the node to which the closest node is to be found
     * @return the closest node to the given node
     */
    public ONode findClosestNode(ONode node){
        //Get the coordinates of the node
        Double latitude = node.getLatitude();
        Double longitude = node.getLongitude();

        //Assign default variables
        AtomicReference<Double> minDistance = new AtomicReference<>(Double.MAX_VALUE);
        AtomicReference<ONode> closestNode = new AtomicReference<>(node);

        //Loop through all the nodes that are not from Rider type, and find the closest one
        this.nodes.values().stream().filter(n -> n.getUser() != ONode.userType.Rider)
                .forEach(other -> {
                    double dist = GraphAlgo.distance(node, other);
                    if(dist < minDistance.get()){
                        minDistance.set(dist);
                        closestNode.set(other);
                    }
                });

        return closestNode.get();
    }

    @Override
    public String toString() {
        return "OGraph{" +
                "edges=" + this.edges.size() +
                ", nodes=" + this.nodes.size() +
                '}';
    }
}