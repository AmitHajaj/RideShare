package osmProcessing;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

public class OGraph {
    // edges id generated by calculacateEdgeId() method below:
    private Map<Long, OEdge> edges;
    // access through node id:
    private Map<Long, ONode> nodes;
    private Map<Long, ONode> riders;

    private Map<Long, ONode> junctionNodes = new HashMap<>();

    HashMap<Long, Integer> nodesQuantity = new HashMap<>();

    /**
     * Singleton specific properties:
     */

    private static OGraph INSTANCE = new OGraph();

    private OGraph() {
        this.edges = new HashMap<>();
        this.nodes = new HashMap<>();
        this.riders = new HashMap<>();
    }

    public static OGraph getInstance() {
        return INSTANCE;
    }


//    /**
//     * Create graph edges
//     * @param ways
//     * @param objects
//     */
//    public void parseMapWays(ArrayList<OMapWay> ways, Map<Long, MapObject> objects) {
//
//        for (OMapWay way: ways) {
//
//            // Create first edge between the first and the last objects:
//            HashMap<Long, MapObject> objectsOnWay = (HashMap<Long, MapObject>) way.getObjects();
//
//            if (objectsOnWay.isEmpty() == false && objectsOnWay.size() >= 2) {//TODO check if node have irrelevant tags
//
//                ONode start = createNodeForEdge(way.getFirst(), way);
//                ONode target = createNodeForEdge(way.getLast(), way);
//
//                OEdge edge = new OEdge(way, start, target);
//                this.edges.put(this.calculateEdgeId(edge), edge);
//
//                // iterate through other objects on way (first and last one polled):
//                for (MapObject object: way.getObjectsList()) {
//                    // check whether the object was referenced by other ways:
//                    Integer nodeReferenceNum = OGraph.getInstance().nodesQuantity.get(object.getID());
//                    if (object.linkCounter > 1) {
//                        // if so, split way into two edges at this point:
//                        edge = splitEdgeAt(object, edge, way);
//                    }
//
//                }
//            }
//        }
//
//        // add edges to nodes and calculate final distance:
//        for (OEdge e: this.getEdgesList()) {
//            if(!e.getStartNode().isAdjacent(e.getEndNode())) {
//                // TODO make edge bi-directional if needed
//                e.getStartNode().addEdge(e);
//                e.getEndNode().addEdge(e);
//            }
//
//            // calculate distance:
//            e.calculateDistance();
//        }
//
//    }
//
//    private ONode createNodeForEdge(MapObject mapObject, OMapWay way){
//        ONode node = this.selectNode(mapObject);
//
//        node.addTags(way.getTags());
//        node.addWayID(way.getID());
//
//        return node;
//    }
//
//    private ONode selectNode(MapObject object) {
//        Long junctionID = Reader.getJunctions().get(object.getID());
//        ONode node = this.nodes.get(object.getID());
//
//        if(junctionID == null){
//            if(node == null){
//                node = new ONode(object);
//                this.nodes.put(object.getID(), node);
//            }
//        }else{
//            // node is part of a junction
//            node = this.nodes.get(junctionID);
//            if(node == null){
//                node = junctionNodes.get(junctionID);
//
//                if(node == null){
//                    node = new ONode(object);
//                    junctionNodes.put(junctionID, node);
//                    this.nodes.put(object.getID(), node);
//                }
//
//            }
//
//
//        }
//        return node;
//    }

//    /**
//     * @param obj object at which edge will be splitted:
//     * @param edge in input: start--target connection
//     * @param baseWay base for new edge
//     * Method creates start-X-target such connection
//     * Where X is a new node created from @param obj
//     * @return the right part of above connection: X-target
//     */
//    private OEdge splitEdgeAt(MapObject obj, OEdge edge, OMapWay baseWay) {
//        // remove old edge between two nodes:
//        this.edges.remove(this.calculateEdgeId(edge));
//        // get node at the middle:
//        ONode node = this.selectNode(obj);
//        // connect it to start and target of edge:
//        OEdge leftEdge = new OEdge(baseWay, edge.getStartNode(), node);
//        OEdge rightEdge = new OEdge(baseWay, node, edge.getEndNode());
//
//        this.edges.put(this.calculateEdgeId(leftEdge), leftEdge);
//        this.edges.put(this.calculateEdgeId(rightEdge), rightEdge);
//
//        return rightEdge;
//    }

//    /**
//     * custom created edges have no id
//     * TODO find more memory-efficient way to id edges
//     * TODO e.g. by using hash values or something
//     * @param edge
//     * @return
//     */
//    private Long calculateEdgeId(OEdge edge) {
//        return (long)(edge.getStartNode().getID()+edge.getEndNode().getID());
//    }

    /**
     * Getters:
     */

//    public ArrayList<OEdge> getEdges() {
//        ArrayList<OEdge> edges = new ArrayList<OEdge>();
//        for(ONode node : this.nodes.values()) {
//            ArrayList<OEdge> incidentEdges = node.getIncidentEdges();
//            edges.addAll(incidentEdges);
//        }
//        return edges;

//    }

    public Map<Long, OEdge> getEdges() {
        return edges;
    }

    public Map<Long, ONode> getNodes() {
        return nodes;
    }

    public ONode getNode(long key){
        ONode node = this.nodes.get(key);
        return node == null? this.riders.get(key): node;
    }

    public Map<Long, ONode> getJunctionNodes() {
        return junctionNodes;
    }

    /**
     * Setters:
     */

    public OEdge addEdge(long id, OEdge e){
        this.edges.put(id, e);
        return e;
    }

    public ONode addNode(ONode node, long id){
        nodes.put(id, node);
        return node;
    }

//    public ONode addDriverNode(long userID){
//        ONode node = new ONode(userID, )
//        node.setUser(ONode.userType.Rider);
//
//        return node;
//    }

    public ONode addRiderNode(long id, Double[] coordinates){
        ONode node = new ONode(id, coordinates, ONode.userType.Rider);
        node.setUser(ONode.userType.Rider);
        riders.put(id, node);
        return node;
    }

    public Map<Long, ONode> getRiders() {
        return riders;
    }

    public OEdge removeEdge(long id){
        return this.edges.remove(id);
    }

    /**
     * Function to find the closest node to a given point
     * @param node- the node to which the closest node is to be found
     * @return the closest node to the given node
     */
    public ONode findClosestNode(ONode node){
        //Get the coordinates of the node
        Double latitude = node.getLatitude();
        Double longitude = node.getLongitude();

        //Assign default variables
        AtomicReference<Double> minDistance = new AtomicReference<>(Double.MAX_VALUE);
        AtomicReference<ONode> closestNode = new AtomicReference<>(node);

        //Loop through all the nodes that are not from Rider type, and find the closest one
        this.nodes.values().stream().filter(n -> n.getUser() != ONode.userType.Rider)
                .forEach(n -> {
                    double dist = Utils.getInstance().distance(latitude, longitude, n.getLatitude(), n.getLongitude());
                    if(dist < minDistance.get()){
                        minDistance.set(dist);
                        closestNode.set(n);
                    }
                });

        return closestNode.get();
    }
}
