package osmProcessing;

import java.util.*;

public class OGraph {
    // edges id generated by calculacateEdgeId() method below:
    private Map<Long, OEdge> edges;
    // access through node id:
    private Map<Long, ONode> nodes;

    /**
     * Singleton specific properties:
     */

    private static OGraph INSTANCE = new OGraph();

    private OGraph() {
        this.edges = new HashMap<Long, OEdge>();
        this.nodes = new HashMap<Long, ONode>();
    }

    public static OGraph getInstance() {
        return INSTANCE;
    }


    /**
     * Create graph edges
     * @param ways
     * @param objects
     */
    public void parseMapWays(ArrayList<OMapWay> ways, Map<Long, MapObject> objects) {

        for (OMapWay way: ways) {

            // Create first edge between the first and the last objects:
            HashMap<Long, MapObject> objectsOnWay = (HashMap<Long, MapObject>) way.getObjects();

            if (objectsOnWay.isEmpty() == false && objectsOnWay.size() >= 2) {

                ONode start = this.selectNode(way.pollFirstObject());
                ONode target = this.selectNode(way.pollLastObject());

                OEdge edge = new OEdge(way, start, target);
                this.edges.put(this.calculateEdgeId(edge), edge);

                // iterate through other objects on way (first and last one polled):
                for (MapObject object: way.getObjectsList()) {
                    // check whether the object was referenced by other ways:
                    if (object.linkCounter > 1) {
                        // if so, split way into two edges at this point:
                        edge = splitEdgeAt(object, edge, way);
                    }

                }
            }
        }

        // add edges to nodes and calculate final distance:
        for (OEdge e: this.getEdgesList()) {
            e.getStartNode().addEdge(e);
            e.getEndNode().addEdge(e);
            // calculate distance:
            e.calculateDistance();
        }

    }

    /**
     * get node from nodes to corresponding object
     * if no node there -> create new node
     * @param object
     * @return corresponding node
     */
    private ONode selectNode(MapObject object) {
        ONode node = this.nodes.get(object.getID());
        if (node == null) {
            node = new ONode(object);
            this.nodes.put(object.getID(), node);
        }

        return node;
    }

    /**
     * @param obj object at which edge will be splitted:
     * @param edge in input: start--target connection
     * @param baseWay base for new edge
     * Method creates start-X-target such connection
     * Where X is a new node created from @param obj
     * @return the right part of above connection: X-target
     */
    private OEdge splitEdgeAt(MapObject obj, OEdge edge, OMapWay baseWay) {
        // remove old edge between two nodes:
        this.edges.remove(this.calculateEdgeId(edge));
        // get node at the middle:
        ONode node = this.selectNode(obj);
        // connect it to start and target of edge:
        OEdge leftEdge = new OEdge(baseWay, edge.getStartNode(), node);
        OEdge rightEdge = new OEdge(baseWay, node, edge.getEndNode());

        this.edges.put(this.calculateEdgeId(leftEdge), leftEdge);
        this.edges.put(this.calculateEdgeId(rightEdge), rightEdge);

        return rightEdge;
    }

    /**
     * custom created edges have no id
     * TODO find more memory-efficient way to id edges
     * TODO e.g. by using hash values or something
     * @param edge
     * @return
     */
    private Long calculateEdgeId(OEdge edge) {
        return (long)(edge.getStartNode().getID()+edge.getEndNode().getID());
    }

    /**
     * Getters:
     */

    public List<OEdge> getEdgesList() {
        return new LinkedList<OEdge>(this.edges.values());
    }


    public ArrayList<OEdge> getEdges() {
        ArrayList<OEdge> edges = new ArrayList<OEdge>();
        for(ONode node : this.nodes.values()) {
            ArrayList<OEdge> incidentEdges = node.getIncidentEdges();
            edges.addAll(incidentEdges);
        }
        return edges;
    }

    public List<ONode> getNodesList() {
        return new LinkedList<ONode>(this.nodes.values());
    }

    public ONode getNode(long key){
        return this.nodes.get(key);
    }
}
