package osmProcessing;

import org.apache.commons.math3.util.Pair;

import java.util.*;

public class OGraph {
    // edges id generated by calculacateEdgeId() method below:
    private Map<Long, OEdge> edges;
    // access through node id:
    private Map<Long, ONode> nodes;
    private Map<Long, ONode> junctionNodes = new HashMap<>();

    HashMap<Long, Integer> nodesQuantity = new HashMap<>();

    /**
     * Singleton specific properties:
     */

    private static OGraph INSTANCE = new OGraph();

    private OGraph() {
        this.edges = new HashMap<Long, OEdge>();
        this.nodes = new HashMap<Long, ONode>();
    }

    public static OGraph getInstance() {
        return INSTANCE;
    }


    /**
     * Create graph edges
     * @param ways
     * @param objects
     */
    public void parseMapWays(ArrayList<OMapWay> ways, Map<Long, MapObject> objects) {

        for (OMapWay way: ways) {
//            boolean right = false, left = false , roundabout = false;
//            if(way.getID() == 85568828l ){
//                roundabout = true;
//            }
//            else if(way.getID() == 155117788l ){
//                left = true;
//            }
//            else if(way.getID() == 539167076l ){
//                right = true;
//            }

            // Create first edge between the first and the last objects:
            HashMap<Long, MapObject> objectsOnWay = (HashMap<Long, MapObject>) way.getObjects();

            if (objectsOnWay.isEmpty() == false && objectsOnWay.size() >= 2) {
                //TODO check if node have irrelevant tags
                ONode start = this.selectNode(way.getFirst());
//                start.addTags("edge", "source");
                start.addTags(way.getTags());
                start.addWayID(way.getID());
                ONode target = this.selectNode(way.getLast());
                target.addTags(way.getTags());
//                target.addTags("edge", "destination");
                target.addWayID(way.getID());
                OEdge edge = new OEdge(way, start, target);
                this.edges.put(this.calculateEdgeId(edge), edge);

                // iterate through other objects on way (first and last one polled):
                for (MapObject object: way.getObjectsList()) {
                    // check whether the object was referenced by other ways:
                    Integer nodeReferenceNum = OGraph.getInstance().nodesQuantity.get(object.getID());
                    if (object.linkCounter > 1) {
                        // if so, split way into two edges at this point:
                        edge = splitEdgeAt(object, edge, way);
                    }

                }
            }
        }

        // add edges to nodes and calculate final distance:
        for (OEdge e: this.getEdgesList()) {
            e.getStartNode().addEdge(e);
            e.getEndNode().addEdge(e);
            // calculate distance:
            e.calculateDistance();
        }

    }


    private ONode selectNode(MapObject object) {
        if(object.getID() == 5329510743l){
            boolean stop = true;
        }

        Long junctionID = Reader.getJunctions().get(object.getID());
        ONode node = this.nodes.get(object.getID());

    //    if(object.getID() == 992691829l || object.getID() == 992691850l || object.getID() == 7222576515l){
    ////            7222576515 right
    ////            992691850 down
    ////            992691829 top
    //            boolean stop = true;
    //        }

        if(junctionID == null){
            if(node == null){
                node = new ONode(object);
                this.nodes.put(object.getID(), node);
            }
        }else{
            // node is part of a junction
            if(junctionID == 985633358l){
                boolean stop = true;
            }
            node = this.nodes.get(junctionID);
            if(node == null){
                node = junctionNodes.get(junctionID);

                if(node == null){
                    node = new ONode(object);
                    junctionNodes.put(junctionID, node);
                    this.nodes.put(object.getID(), node);
                }

            }


        }
        return node;
    }


//
//
//
//
//    //node is part of a junction
//    if(junctionID != null){
////        ONode junctionNode1 = getJunctionNode(junctionID, object);
//
//
//        ONode junctionNode = this.nodes.get(junctionID);
//
//        if (junctionNode == null) {
//            junctionNode = junctionNodes.get(junctionID);
//
//            if(junctionNode == null){
//                junctionNode = new ONode(object);
//                junctionNodes.put(junctionID, junctionNode);
//            }
//        }
//
//        this.nodes.put(object.getID(), junctionNode);
////        // if new node
////        ONode junctionNode = this.nodes.get(junctionID);
////        if (junctionNode == null) {
////
////            junctionNode = junctionNodes.get(junctionID);
////
////            if(junctionNode == null){
////                junctionNodes.put(junctionID, new ONode(object));
////            }
////        }
//    }else{
//        ONode node = this.nodes.get(object.getID());
//    }
//
//    if(object.getID() == 992691829l || object.getID() == 992691850l || object.getID() == 7222576515l){
////            7222576515 right
////            992691850 down
////            992691829 top
//        boolean stop = true;
//    }
//    return node;
////    if (node == null) {
////        node = new ONode(object);
////        this.nodes.put(object.getID(), node);
////    }
//
////    return node;
//}


    /**
     * @param obj object at which edge will be splitted:
     * @param edge in input: start--target connection
     * @param baseWay base for new edge
     * Method creates start-X-target such connection
     * Where X is a new node created from @param obj
     * @return the right part of above connection: X-target
     */
    private OEdge splitEdgeAt(MapObject obj, OEdge edge, OMapWay baseWay) {
        // remove old edge between two nodes:
        this.edges.remove(this.calculateEdgeId(edge));
        // get node at the middle:
        ONode node = this.selectNode(obj);
        // connect it to start and target of edge:
        OEdge leftEdge = new OEdge(baseWay, edge.getStartNode(), node);
        OEdge rightEdge = new OEdge(baseWay, node, edge.getEndNode());

        this.edges.put(this.calculateEdgeId(leftEdge), leftEdge);
        this.edges.put(this.calculateEdgeId(rightEdge), rightEdge);

        return rightEdge;
    }

    /**
     * custom created edges have no id
     * TODO find more memory-efficient way to id edges
     * TODO e.g. by using hash values or something
     * @param edge
     * @return
     */
    private Long calculateEdgeId(OEdge edge) {
        return (long)(edge.getStartNode().getID()+edge.getEndNode().getID());
    }

    /**
     * Getters:
     */

    public List<OEdge> getEdgesList() {
        return new LinkedList<OEdge>(this.edges.values());
    }


    public ArrayList<OEdge> getEdges() {
        ArrayList<OEdge> edges = new ArrayList<OEdge>();
        for(ONode node : this.nodes.values()) {
            ArrayList<OEdge> incidentEdges = node.getIncidentEdges();
            edges.addAll(incidentEdges);
        }
        return edges;
    }

    public List<ONode> getNodesList() {
        return new LinkedList<ONode>(this.nodes.values());
    }

    public ONode getNode(long key){
        return this.nodes.get(key);
    }
}
